import pyphonetics

from .exceptions import PhoneticAlgorithmError, UnicodeException
from .calculateStringDistance import jaccardDistance, jaccardDistanceNGram, editDistance

rs = pyphonetics.RefinedSoundex()
metaphone = pyphonetics.Metaphone()
soundex = pyphonetics.Soundex()
fuzzy_soundex = pyphonetics.FuzzySoundex()
mra = pyphonetics.MatchingRatingApproach()


# Phonetic representation is generated by pyphonetics.RefinedSoundex()
def refinedSoundexRep(word):
    return rs.phonetics(word)


# Generate metaphone representations for words. See https://en.wikipedia.org/wiki/Metaphone
def metaPhoneRep(wordString):
    return metaphone.phonetics(wordString)


# Generate fuzzy soundex representation for words. See: Holmes, David and M. Catherine McCabe. "Improving Precision
# and Recall for Soundex Retrieval."
# http://web.archive.org/web/20100629121128/http://www.ir.iit.edu/publications/downloads/IEEESoundexV5.pdf
def fuzzySoundexRep(wordString):
    return fuzzy_soundex.phonetics(wordString)


# Generate soundex representation for words. See: https://en.wikipedia.org/wiki/Soundex
def soundexRep(wordString):
    return soundex.phonetics(wordString)


# Generate matchting rating approach representation for words. See: https://en.wikipedia.org/wiki/Match_rating_approach
def mraRep(wordString):
    return mra.phonetics(wordString)


class PhoneticRepresentation:
    """
        The main Phonetic Representation class, to ensure a unified API
        for all the included algorithms.
    """

    def __init__(self, algo):
        self.algorithm = {'metaphone': metaPhoneRep, 'soundex': soundexRep, 'fuzzy': fuzzySoundexRep,
                          'refined_soundex': refinedSoundexRep, 'mra': mraRep}
        self.func = algo
        if self.func in self.algorithm:
            self.func = self.algorithm[self.func]
        else:
            raise PhoneticAlgorithmError('Invalid Phonetic Algorithm.')

    def phonetics(self, wordString):
        if not isinstance(wordString, str):
            raise UnicodeException('Expected a unicode string!')
        return self.func(wordString)

    def edit_distance(self, word1, word2):
        if isinstance(word1, str) and isinstance(word2, str):
            return editDistance(word1, word2)
        else:
            raise UnicodeException('Expected a unicode string!')

    def jaccard_distance(self, word1, word2):
        if isinstance(word1, str) and isinstance(word2, str):
            return jaccardDistance(word1, word2)
        else:
            raise UnicodeException('Expected a unicode string!')

    def jaccard_ngram(self, word1, word2, n=3):
        if isinstance(word1, str) and isinstance(word2, str):
            return jaccardDistanceNGram(word1, word2, n)
        else:
            raise UnicodeException('Expected a unicode string!')
