import re

import numba
import pyphonetics
from num2words import num2words

from .calculateStringDistance import jaccardDistance, jaccardDistanceNGram, editDistance
from .exceptions import PhoneticAlgorithmError, UnicodeException

rs = pyphonetics.RefinedSoundex()
metaphone = pyphonetics.Metaphone()
soundex = pyphonetics.Soundex()
fuzzy_soundex = pyphonetics.FuzzySoundex()
mra = pyphonetics.MatchingRatingApproach()


# Phonetic representation is generated by pyphonetics.RefinedSoundex()
def refinedSoundexRep(word):
    return rs.phonetics(word)


# Generate metaphone representations for words. See https://en.wikipedia.org/wiki/Metaphone
def metaPhoneRep(wordString):
    return metaphone.phonetics(wordString)


# Generate fuzzy soundex representation for words. See: Holmes, David and M. Catherine McCabe. "Improving Precision
# and Recall for Soundex Retrieval."
# http://web.archive.org/web/20100629121128/http://www.ir.iit.edu/publications/downloads/IEEESoundexV5.pdf
def fuzzySoundexRep(wordString):
    return fuzzy_soundex.phonetics(wordString)


# Generate soundex representation for words. See: https://en.wikipedia.org/wiki/Soundex
def soundexRep(wordString):
    return soundex.phonetics(wordString)


# Generate matchting rating approach representation for words. See: https://en.wikipedia.org/wiki/Match_rating_approach
def mraRep(wordString):
    return mra.phonetics(wordString)


class PhoneticRepresentation:
    """
        The main Phonetic Representation class, to ensure a unified API
        for all the included algorithms.
    """

    def __init__(self, algo):
        self.algorithm = {'metaphone': metaPhoneRep, 'soundex': soundexRep, 'fuzzy': fuzzySoundexRep,
                          'refined_soundex': refinedSoundexRep, 'mra': mraRep}
        self.func = algo
        if self.func in self.algorithm:
            self.func = self.algorithm[self.func]
        else:
            raise PhoneticAlgorithmError('Invalid Phonetic Algorithm.')
        self.replacementDict = {'0': 'o', '1': 'one', '2': 'to', '3': 'three', '4': 'four', '5': "five", '6': "six",
                                '7': 'seven', '8': 'eight', '9': 'nine', '10': 'ten'}

    @numba.jit()
    def wordPreprocess(self, word):
        if not isinstance(word, str):
            raise UnicodeException('Expected a unicode string!')
        charList = list(word)
        for i in range(len(charList)):
            if i == 0 and charList[i] == '0':
                charList[i] = 'o'
            elif charList[i] == '0' and (charList[i - 1] not in '123456789'):
                charList[i] = 'o'
        string = "".join(charList)
        string = re.sub(r' ', "", string)
        dp = re.compile(r"(\d+)")
        m = dp.findall(string)
        for c in m:
            num = int(c)
            p = re.compile(re.escape(c))
            string = re.sub(p, num2words(num), string)
            string = re.sub(r'-', "", string)
            string = re.sub(r' ', "", string)
            string = re.sub(r',', "", string)

        return string



    def phonetics(self, wordString):
        if not isinstance(wordString, str):
            raise UnicodeException('Expected a unicode string!')
        wordString_p = self.wordPreprocess(wordString)
        return self.func(wordString_p)

    def edit_distance(self, word1, word2):
        if isinstance(word1, str) and isinstance(word2, str):
            return editDistance(self.phonetics(word1), self.phonetics(word2))
        else:
            raise UnicodeException('Expected a unicode string!')

    def jaccard_distance(self, word1, word2):
        if isinstance(word1, str) and isinstance(word2, str):
            return jaccardDistance(self.phonetics(word1), self.phonetics(word2))
        else:
            raise UnicodeException('Expected a unicode string!')

    def jaccard_ngram(self, word1, word2, n=3):
        if isinstance(word1, str) and isinstance(word2, str):
            return jaccardDistanceNGram(self.phonetics(word1), self.phonetics(word2), n)
        else:
            raise UnicodeException('Expected a unicode string!')
